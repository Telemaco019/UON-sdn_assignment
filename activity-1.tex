\section*{Lab activity 1}





\subsection*{Learning objectives}
After finishing this lab activity you will be able to:
\begin{itemize}
  \item Implement a cluster of local controller inside Mininet using the python
  middle-level Mininet API
  \item Test the network connectivity and the performance of a network which
  includes a cluster of local controllers
  \item Understand the main functions provided by the middle-level Mininet API required
  to implement a cluster of local controllers
\end{itemize}






\subsection*{Scenario}
In this activity you will implement the simple topology shown in figure *** using
a Python script and the middle-level API provided by Mininet. The two controllers
showned in the topology diagram will be local controllers for this activity.
The topology has two different switches: each one will be connected to a different
local controller.

Begin by creating a new Python script, then import Mininet classes required for
this activity and define the function that will be used to create the topology.
Inside the body of this function, create a new Mininet netowrk and add to it the
required hosts, switches, links and controllers. After writing the script, execute
it to create the network and test its connectivity and performance.

This lab activity assumes you are proficient in [...]. A basic knowledge of the
Python programming language is also assumed.





\subsection*{Task 1: write the skeleton of the Python script}
\subsubsection*{Step 1}
Create a new python script and edit with the text editor you prefer. If your editing
it inside the Mininet virtual machine, it is suggested to use Vim text editor.

\subsubsection*{Step 2}
Import the Python classes from the Mininet API:
\begin{lstlisting}
#!/usr/bin/python
from mininet.net import Mininet
from mininet.node import Controller, OVSSwitch
from mininet.cli import CLI
from mininet.log import setLogLevel, info
\end{lstlisting}

\subsubsection*{Step 3}
Make the script executable onyl as a program, set the log level to ``info''
and call the function \code{multiControllerNet()}, which will be defined in the next
step:
\begin{lstlisting}
if __name__ == '__main__':
    setLogLevel( 'info' )
    multiControllerNet()
\end{lstlisting}

\subsubsection*{Step 4}
Define the function that will be used to create the topology:
\begin{lstlisting}
def multiControllerNet():
\end{lstlisting}

\subsubsection*{Step 6}
Inside the body of the function \code{multiControllerNet()} create a new Mininet
network:
\begin{lstlisting}
net = Mininet( controller=Controller, switch=OVSSwitch )
\end{lstlisting}

The Mininet network is created invoking the Mininet constructor: the parameters
passed to the constructor are the Controller class and the OVSSwitch class, therefore
the Stanford/OpenFlow reference controllers and Open vSwitch switches will be used
in the network we are goind to create. Note that these two classes are
the default parameters in the Mininet constructor, so it is not really necessary
to specify them.

\subsubsection*{Step 7}
Save the text file as ``\emph{controllers-1.py}'' in your custom directory inside
the mininet virtual machine.





\subsection*{Task 2: add hosts to the network}
\subsubsection*{Step 1}
Inside the body of the function \code{multiControllerNet()} add the following line
of code in order to print to the console that hosts are being created:
\begin{lstlisting}
info( "*** Creating hosts \n" )
\end{lstlisting}

\subsubsection*{Step 2}
Still inside the body of the function \code{multiControllerNet()}, create the
four hosts required for the topology by adding them to the mininet network
previously created:
\begin{lstlisting}
h1 = net.addHost('h3')
h2 = net.addHost('h4')
h3 = net.addHost('h5')
h4 = net.addHost('h6')
\end{lstlisting}
The function used to add the hosts to the network is \code{addHost('name')}, which
accept as parameter the name of the host that will be created. The hosts names in
this network therefore will we \code{h3}, \code{h4}, \code{h5} and \code{h6}.





\subsection*{Task 3: add switches to the network}
\subsubsection*{Step 1}
Inside the body of the function \code{multiControllerNet()} add the following line
of code in order to print to the console that switches are being created:
\begin{lstlisting}
info( "*** Creating switches \n" )
\end{lstlisting}

\subsubsection*{Step 2}
Still inside the body of the function \code{multiControllerNet()}, create the
two switches required for the topology by adding them to the mininet network
previously created:
\begin{lstlisting}
s1 = net.addSwitch('s1')
s2 = net.addSwitch('s2')
\end{lstlisting}







\subsection*{Task 4: create links between nodes}
\subsubsection*{Step 1}
Inside the body of the function \code{multiControllerNet()} add the following line
of code in order to print to the console that links are being created:
\begin{lstlisting}
info( "*** Creating links \n" )
\end{lstlisting}

\subsubsection*{Step 2}
Still inside the body of the function \code{multiControllerNet()}, create four
links between the hosts and the switches and the link between the two switches:
\begin{lstlisting}
net.addLink( h3, s1 )
net.addLink( h4, s1 )
net.addLink( h5, s2 )
net.addLink( h6, s2 )
net.addLink( s1, s2 )
\end{lstlisting}








\subsection*{Step 5: create controllers} \label{sec:step-5}
In this step we are going to create two local SDN controllers. The code we have to
add to the script is the following:

\code{info( "*** Creating (reference) controllers\textbackslash n" )} \\
\code{c1 = net.addController( 'c1', port=6633 )} \\
\code{c2 = net.addController( 'c2', port=6634 )}

Note that we specified a different TCP port for each controller (the controllers
will listen on the specified port for switches that want to set up a connection).

\textbf{Why did we specify a different port for each controller?}

\hrulefill

\hrulefill
% Because each swtich has to setup one TCP connection to each controller and
% it's not possible having more than one TCP connection on the same port, so
% specifying two different ports makes it possible to connect one single switch
% to multiple controllers.


\subsection*{Step 6: start the network}
After adding all the required nodes to the network we can finally start it. In order
to do that, we have to build the mininet network and start the controllers and the
switches:

\code{info( "*** Starting network\textbackslash n" )} \\
\code{net.build()} \\
\code{c1.start()} \\
\code{c2.start()} \\
\code{s1.start( [ c1 ] )} \\
\code{s2.start( [ c2 ] )}

In the last two lines of code we used the function start() to start the two switches,
passing as parameter

After this step, the python script required to build the topology for the task one
is completed. The full script is shown in listing \ref{lst:task-1-complete-script}.



\subsection{Step 7: test network connectivity and performance}
The final step is execute the script and test the created topology: try to verify
the network connectivity between all hosts and the bandwidth between \code{h3} and \code{h6}.
Write in the lines below the commands you used and the results you obtained.

\hrulefill

\hrulefill

\hrulefill

\begin{lstlisting}[label=lst:task-1-complete-script, caption=Task 1 complete python script]
#!/usr/bin/python
from mininet.net import Mininet
from mininet.node import Controller, OVSSwitch
from mininet.cli import CLI
from mininet.log import setLogLevel, info

def multiControllerNet():
    net = Mininet( controller=Controller, switch=OVSSwitch )

    info( "*** Creating hosts\n" )
    h1 = net.addHost('h3')
    h2 = net.addHost('h4')
    h3 = net.addHost('h5')
    h4 = net.addHost('h6')

    info( "*** Creating switches\n" )
    s1 = net.addSwitch( 's1' )
    s2 = net.addSwitch( 's2' )

    info( "*** Creating links\n" )
    net.addLink( h3, s1 )
    net.addLink( h4, s1 )
    net.addLink( h5, s2 )
    net.addLink( h6, s2 )
    net.addLink( s1, s2 )

    info( "*** Creating (reference) controllers\n" )
    c1 = net.addController( 'c1', port=6633 )
    c2 = net.addController( 'c2', port=6634 )

    info( "*** Starting network\n" )
    net.build()
    c1.start()
    c2.start()
    s1.start( [ c1 ] )
    s2.start( [ c2 ] )

    info( "*** Running CLI\n" )
    CLI( net )

    info( "*** Stopping network\n" )
    net.stop()

if __name__ == '__main__':
    setLogLevel( 'info' )  # for CLI output
    multiControllerNet()
\end{lstlisting}
